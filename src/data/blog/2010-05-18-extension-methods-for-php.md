---
layout: post
title: "Extension methods for PHP"
pubDatetime: 2010-05-18T10:35:00Z
comments: true
published: true
categories: ["post"]
tags: ["General", "PHP", "Projects", "Software"]
author: Maarten Balliauw
redirect_from:
  - /post/2010/05/18/extension-methods-for-php.html
---
<p><img style="border-right-width: 0px; margin: 5px 0px 5px 5px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="PHP Extension Methods" border="0" alt="PHP Extension Methods" align="right" src="/images/image_47.png" width="240" height="164" /> The concept of “extension” methods will be nothing new to this blog’s .NET-related audience. For the PHP-related audience, this is probably something new. Let’s start with the official definition for extension methods: <em>Extension methods enable you to &quot;add&quot; methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type. Extension methods are a special kind of static method, but they are called as if they were instance methods on the extended type.</em></p>  <p>Let’s visualize this. Imagine having the following class:</p>  <p>[code:c#]</p>  <p>class HelloWorld    <br />{     <br />&#160;&#160;&#160; public function sayHello($to = 'World', $from = null)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $helloString = &quot;Hello, &quot; . $to . &quot;!&quot;;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!is_null($from)) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $helloString .= &quot; From &quot; . $from;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } </p>  <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; echo $helloString . &quot;\r\n&quot;;    <br />&#160;&#160;&#160; }     <br />}</p>  <p>[/code]</p>  <p>Not too difficult. There’s a s<em>ayHello() </em>method that allows you to optionally pass who should be greeted and who the greeting is from. Imagine you would like to have a <em>sayHelloTo()</em> method as well, a shortcut to <em>sayHello($to)</em>. And some other helper methods that use s<em>ayHello() </em>under the hood. Wouldn’t it be nice to have the <em>HelloWorld</em> class concentrating on the real logic and defining the helper/utility functions somewhere else? How about a class named <em>HelloExtensions</em>:</p>  <p>[code:c#]</p>  <p>class HelloWorldExtensions    <br />{     <br />&#160;&#160;&#160; public static function sayHelloTo(HelloWorld $subject, $name = '')     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $subject-&gt;sayHello($name);     <br />&#160;&#160;&#160; } </p>  <p>&#160;&#160;&#160; public static function sayHelloFrom(HelloWorld $subject, $name = '')    <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $subject-&gt;sayHello('World', $name);     <br />&#160;&#160;&#160; }     <br />}</p>  <p>[/code]</p>  <p>Ok, nice. But this means I should call <em>HelloWorldExtensions::sayHelloTo(‘Maarten’);</em> to use the utility functions, right? Well: no! Not if we implement the concept of extension methods. Let’s see what we can do to <em>HelloWorld</em> in order to make our life easier.</p>  <p>[code:c#]</p>  <p>class HelloWorld    <br />{     <br />&#160;&#160;&#160; public function sayHello($to = 'World', $from = null)     <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $helloString = &quot;Hello, &quot; . $to . &quot;!&quot;;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; if (!is_null($from)) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $helloString .= &quot; From &quot; . $from;     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; } </p>  <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; echo $helloString . &quot;\r\n&quot;;    <br />&#160;&#160;&#160; } </p>  <p>&#160;&#160;&#160; public function __call($functionName, $arguments = array())    <br />&#160;&#160;&#160; {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Add an extra parameter     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; array_unshift($arguments, $this); </p>  <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Current reflected class    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $reflectedClass = new reflectionObject($this); </p>  <p>&#160;&#160;&#160;&#160;&#160;&#160;&#160; // Find suitable class and function    <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; $availableClasses = get_declared_classes();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; foreach ($availableClasses as $class) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $classDefinition = new ReflectionClass($class);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $availableMethods = $classDefinition-&gt;getMethods();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; foreach ($availableMethods as $method) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ($method-&gt;isStatic() &amp;&amp; $method-&gt;getName() == $functionName) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $availableParameters = $method-&gt;getParameters();     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; if ($availableParameters[0]-&gt;getClass()-&gt;getName() == $reflectedClass-&gt;getName()) {     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; $method-&gt;invokeArgs(null, $arguments);     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }     <br />&#160;&#160;&#160; }     <br />}</p>  <p>[/code]</p>  <p>The magic method <em>__call()</em> is used to look for a class that defines a static method with the first parameter of our type, <em>HelloWorld</em>. This now allows us to write very clean calls to code, as well as simplify our <em>HelloWorld </em>class:</p>  <p>[code:c#]</p>  <p>$helloWorld = new HelloWorld();    <br />$helloWorld-&gt;sayHello();     <br />$helloWorld-&gt;sayHelloTo('Maarten');     <br />$helloWorld-&gt;sayHelloFrom('Maarten');</p>  <p>[/code]</p>  <p>Sweet, no? Can someone get this into the PHP core? I would greatly appreciate it: my classes can focus on functionality and all utility functions that just pass around variables can be defined in a separate class.</p>



